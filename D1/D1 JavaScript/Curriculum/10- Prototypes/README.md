# Outcome 10 - Prototypes 

## Skill Description
A person with this skill can explain what it means to say that JavaScript is a “prototype language”, and how that differs from class-based languages. They can make use of the prototype chain for inheritance to optimize the efficiency of their code.

## Output: 

- **Task:** Write a JavaScript program with at least four objects that inherit properties from a prototype.
- **Resources:** Build a prototype inheritance chain into your program.
- **Include:** N/A



-------

### Knowledge

| Knowledge Unit   |      Studied      | Applied |
|:-------------|:------------------:|:--------:|
| Definition of a prototype | [ ] | [ ] |
| Difference between prototype languages and class-based languages | [ ] | [ ] |
| Relationship between JavaScript objects and prototypes | [ ] | [ ] |
| How to create prototypes | [ ] | [ ] |
| How to change a function’s prototype | [ ] | [ ] |
| Difference between instance vs. prototype properties | [ ] | [ ] |
| The distinction between prototype properties and prototype attributes | [ ] | [ ] |
| How inheritance works in JavaScript (and how it is different from other programming languages) | [ ] | [ ] |
| How to work with multi-level inheritance | [ ] | [ ] |
| Difference between prototypal inheritance vs. classical inheritance | [ ] | [ ] |
| The distinction between encapsulation and inheritance | [ ] | [ ] |



-------

### Behaviors

| Observable Behavior   |      Practiced      | Observed |
|:-------------|:------------------:|:--------:|
| **Context:** When I am creating an object prototype, **Action:** I use an object constructor function. |   [ ]   |   [ ] |
| **Context:** When I want to add methods to existing constructors, **Action:** I use the prototype property. |   [ ]   |   [ ] |
| **Context:** When I am modifying a prototype, **Action:** I modify only my own prototypes, never the prototypes of standard JavaScript objects. |   [ ]   |   [ ] |
| **Context:** When I create a JavaScript function, **Action:** I change its prototype property from the empty default if necessary. |   [ ]   |   [ ] | 
| **Context:** When I have an object that needs to inherit features from another object, **Action:** I use prototypes. |   [ ]   |   [ ] |
| **Context:** When I am using inheritance, **Action:** I minimize the number of levels of inheritance I include and keep careful track of where I define my methods and properties. |   [ ]   |   [ ] |
| **Context:** Whenever I am using methods or properties defined on a web API or a browser object, **Action:** I am implicitly using inheritance. |   [ ]   |   [ ] | 
| **Context:** When I want optimal code performance in my JavaScript code, **Action:** I use prototypes. |   [ ]   |   [ ] |





-------

### Beliefs

| Embodied Belief   |      Felt      | Demonstrated |
|:-------------|:------------------:|:--------:|
| Understanding prototypical inheritance enables me to avoid subtle bugs caused by accessing properties of objects higher up the prototype chain. |   [ ]   |   [ ] |
| JavaScript prototypes allow me to have a more flexible object model than I could have with a class-based language.  |   [ ]   |   [ ] |
| Being familiar with prototypes will allow me to “see under the hood” of many JavaScript libraries that use them (jQuery, for example). |   [ ]   |   [ ] |
| The prototypal inheritance model is more powerful than the classic model-- I can build a classic model on top of my prototypal model. |   [ ]   |   [ ] |
| Too much inheritance can lead to confusion and endless pain when debugging. | [ ] | [ ] |

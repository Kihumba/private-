# Ruby - Idiomatic Ruby & Refactorings


## Skill Description

A developer is able to write highly expressive Ruby that conforms to a community-driven style guide. A developer is also able to identify pieces of code that can be refactored to achieve a certain goal(s), like optmizing for speed, or making code more readable.


## Output 

**Task:** Using the sample code from the link below, demonstrate how you’d use _Switch Case with Hashes_ method to refactor the code.

[Github - Sample Code](https://github.com/franzejr/best-ruby/blob/master/refactorings/case_with_hashes.md)


### Knowledge
| Knowledge Unit   |      Studied      | Applied |
|:-------------|:------------------:|:--------:|
| What is Enumerable#collect method and how does it work? | [ ] | [ ] |
| What is Enumerable#select method and how does it work? | [ ] | [ ] |
| What is the difference between ‘each’ and ‘map’ methods? | [ ] | [ ] |
| How to use conditional operators to optimize code for readability, maintainability, and concision. | [ ] | [ ] | | [ ] | [ ] |
| How to use Symbol to_proc method. | [ ] | [ ] |
| How to use Fixnum#times method. | [ ] | [ ] |
| What’s the difference between the ‘Collect’ and  ‘Select’ methods? | [ ] | [ ] |
| How to use the Switch Case with Hashes method. | [ ] | [ ] |
| How to refactor fat ActiveRecord models using the following patterns, - _Value Objects, Service Objects, Form Objects, Query Objects, View Objects, Policy Objects and Decorators._ | [ ] | [ ] |

### Behaviors
| Observable Behavior   |      Practiced      | Observed |
|:-------------|:------------------:|:--------:|
| **Context:** When I add more intrinsic complexity (read: features!) to my application, **Action:** I spread it across a coordinated set of small, encapsulated objects and at a higher level—modules. | [ ] | [ ] |
| **Context:** When refactoring fat models, **Action:** I break them down and spread out the logic evenly. | [ ] | [ ] |

### Beliefs
| Embodied Belief   |      Felt      | Demonstrated |
|:-------------|:------------------:|:--------:|
| “Fat models” cause maintenance issues in large apps and they usually represent a failure to apply the Single Responsibility Principle (SRP).| [ ] | [ ] | 
| When refactoring code to improve the quality of Ruby on Rails applications, I learn to break the habit of allowing models to get fat.| [ ] | [ ] | 

Resources

[Github - Refactoring Fat Models](https://github.com/codeclimate/refactoring-fat-models)

[Github - Shaka Code, Refactoring](https://github.com/shakacode/fat-code-refactoring-techniques)

[Ruby Style Guide](https://github.com/bbatsov/ruby-style-guide)

[Ruby - Enumerable](https://ruby-doc.org/core-2.4.1/Enumerable.html)

[Map-Select-and-other-enumerable-methods](http://www.eriktrautman.com/posts/ruby-explained-map-select-and-other-enumerable-methods)


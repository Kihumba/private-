# Outcome 4- Ruby as Object Oriented Programming (OOP)

Skill Description
----------
 A person with this skill can practically model real-life problems and build basic programs to solve them using Ruby as an object oriented programming language. They can explain what Rubyists mean when they say that “everything in Ruby is an object” and why that matters. 


Outputs
----------
- **Task:** Create a basic Ruby application that solves a real world problem that you may encounter on a day-to-day basis
- **Resources:** Making use of OOP principles 
- **Involve:** N/A

----------
## **Knowledge**


| Knowledge Unit   |      Studied      | Applied |
|:-------------|:------------------:|:--------:|
| What developers mean when they say “everything in Ruby is an object” | [ ] | [ ]  |
| The Solid Principles of OOP and how to apply them to Ruby | [ ] | [ ]  |
| The reasoning behind the “Single Responsibility Principle” in OOP | [ ] | [ ]  |
| Definition of Classes and when to use them | [ ] | [ ]  |
| Distinctions between types of Closures in Ruby and when to use each (lambdas, Blocks, and Procs) | [ ] | [ ]  |
| How and when to write Methods in Ruby | [ ] | [ ]  |
| The distinction between the 5 types of variables in Ruby and when to use each | [ ] | [ ]  |
| When to use Inheritance in Ruby | [ ] | [ ]  |
| When and how to use Encapsulation in Ruby | [ ] | [ ]  |
| When to use mixins | [ ] | [ ]  |
| How and when to override a method in Ruby | [ ] | [ ]  |
| What it means for Ruby to be a “Dynamic Language” | [ ] | [ ]  |
| The definition and use of “Duck Typing” in Ruby, and where it gets its name | [ ] | [ ]  |


----------


## **Behaviors**

| Observable Behavior   |      Practiced      | Observed |
|:-------------|:------------------:|:--------:|
| When I want to add functionality to an existing method, I use overriding to ensure that I keep all the method’s original behavior while adding my new behavior to it. | [ ] | [ ]  |
| When I want to pack data and functions into a single component, I use encapsulation. | [ ] | [ ]  |
| When I have a block of code that I want to execute at runtime, I use a proc to insert that code into a method. | [ ] | [ ]  |
| When I want to send the same message to different objects, I use polymorphism. | [ ] | [ ]  |
| When I want to instantiate an object in Ruby, I use the ‘new’ method of a class. | [ ] | [ ]  |
| When I want to create an instance variable, I call the associated method. | [ ] | [ ]  |
| When I have code that works, I go back and refactor using OOP methods to simplify and clean up my code. | [ ] | [ ]  |
| When I have a method that will be called on a class, I use a Class method. | [ ] | [ ]  |
| When I have a method that will be called on an object, I use an instance method. | [ ] | [ ]  |
| When I have a variable that will be used on more than one object, I use an instance variable. | [ ] | [ ]  |
| When I need a variable that will be used only inside a single method, I use Local variables. | [ ] | [ ]  |
| When I have an existing class in Ruby, I can always add methods. | [ ] | [ ]  |

----------


## **Beliefs**

| Embodied Belief   |      Felt      | Demonstrated |
|:-------------|:------------------:|:--------:|
| OOP is a concept any Ruby programmer needs to understand at a high level to model and solve real-world problems. | [ ] | [ ]  |
| Classes are factories that build objects. | [ ] | [ ]  |
| Ruby is a readable language, so I should name my objects in a way that mimics the real world. | [ ] | [ ]  |
| Naming is a form of communication with any other programmers who might later come and read my code. | [ ] | [ ]  |



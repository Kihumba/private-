# Outcome 1 - Test Driven Development(TDD)

Skill Description
----------
Automated tests are likely the best way to achieve confidence in a growing codebase. To amplify that confidence and achieve bigger wins in time savings and code cleanliness, we recommend writing code using a process called Test Driven Development (TDD). TDD is a process that uses tests to drive the design and development of your application. It begins with a development cycle called Red, Green, Refactor.


Output
----------

After attaining this skill, and as a demonstration of it, a person should be able to:

1. Consistently write test and employ TDD when working on Simulation and Checkpoint projects.


## Knowledge

| Knowledge Unit   |      Studied      | Applied |
|:-------------|:------------------:|:--------:|
| What is the difference between manual tests and automated tests | [ ] | [ ] |
| What is TDD | [ ] | [ ] |
| How is TDD related to red-green-refactor | [ ] | [ ] |
| What are the benefits of automated testing | [ ] | [ ] |
| What are the benefits of TDD | [ ] | [ ] |
| What is BDD | [ ] | [ ] |
| What's the difference between TDD and BDD | [ ] | [ ] |
| What do we mean when we say automated tests serve as `living documentation`| [ ] | [ ] |
| Explain how automated tests can save you time and money | [ ] | [ ] |
| What are the instance where TDD will not be a good approach | [ ] | [ ] |
| What's the difference between outside-in development and inside-out development | [ ] | [ ] |
| What's the difference between Test Driven and Test First | [ ] | [ ] |
| Give 5 characteristics of effective test suite | [ ] | [ ] |
| Name 2 test frameworks in at least 3 languages | [ ] | [ ] |
| Types of test | [ ] | [ ] |
| 	1. Unit Test | [ ] | [ ] |
| 	2. Integration Test | [ ] | [ ] |
| 	3. User Acceptance Test(UAT) | [ ] | [ ] |
| 	4. Load Test | [ ] | [ ] |
| What are the 4 phases of testing | [ ] | [ ] |
| What differentiates these two unit testing philosophies namely mockings and classics | [ ] | [ ] |
| What do we mean by unit testing in isolation | [ ] | [ ] |
| What are the inherent dangers of unit testing in isolation | [ ] | [ ] |
| What are the differences between mocks, spies, stubs and fakes | [ ] | [ ] |
| Explain the following testing anti-patterns using code samples where applicable | [ ] | [ ] |
| 	1. Happy path | [ ] | [ ] |
| 	2. Slow pokes | [ ] | [ ] |
| 	3. Obscure tests | [ ] | [ ] |
| 	4. Fragile Tests | [ ] | [ ] |
| 	5. Erratic Tests | [ ] | [ ] |
| 	6. Second Class Citizen | [ ] | [ ] |
| 	7. Test hooks | [ ] | [ ] |
| 	8. No Test | [ ] | [ ] |
| Why are testing anti-patterns such a big issue | [ ] | [ ] |





## Behaviors

| Observable Behavior   |      Practiced      | Observed |
|:-------------|:------------------:|:--------:|
| **Context:** When building an application  **Action:** I write tests before writing code. | [ ] | [ ] |
| **Context:** When building an application  **Action:** I follow red-green-refactor pattern. | [ ] | [ ] |
| **Context:** When I need stakeholders without programming knowledge to understand my tests suite  **Action:** I choose to write my application using BDD development process.  | [ ] | [ ] |
| **Context:** When my application codebase is extremely small and unlikely to change **Action:** I forgo testing all-together.  | [ ] | [ ] |
| **Context:** When a feature I am trying to implement is outside my wheel-house  **Action:** I create exploratory version of the feature before writing my tests  | [ ] | [ ] |
| **Context:** When I have a good understanding of the problem, and have a rough understanding of how the interface and code will work ahead of time  **Action:** I use outside-in development approach | [ ] | [ ] |
| **Context:** When I don't know what my end solution will look like  **Action:** I use inside-out development approach | [ ] | [ ] |
| **Context:** When I need to unit test a class that depends on other classes **Action:** I mock out the other classes using mocks, stubs, spies or fakes  | [ ] | [ ] |
| **Context:** When Testing a single unit(method or class)  **Action:** I test the unit in full isolation | [ ] | [ ] |
| **Context:** When writing test  **Action:** I avoid testing more than one thing at once | [ ] | [ ] |
| **Context:** When setting up remote repository for my application  **Action:** I integrate CI tools to test my application on every push to my repository | [ ] | [ ] |
| **Context:** When setting up my test suites  **Action:** I integrate code coverage tools so as to ascertain how well my code is tested.   | [ ] | [ ] |
| **Context:** When setting up remote repository for my application **Action:** I integrate code coverage tools into my CI tool so as to get test coverage report on each commit. | [ ] | [ ] |
| **Context:** When writing test for my application **Action:** I avoid writing tests that are very slow. | [ ] | [ ] |
| **Context:** When writing integration tests  **Action:** I write my test in such a way as not to introduce erratic behaviors due to javascript race conditions | [ ] | [ ] |
| **Context:** When building an application **Action:** I unit test all my component and test my all application end-to-end  | [ ] | [ ] |
| **Context:** When writing test for my application **Action:** I write test that is easy to read and understand that have no mystery guest.  | [ ] | [ ] |
| **Context:** When writing tests for my application **Action:** I write clean and maintainable test suites  | [ ] | [ ] |
| **Context:** When writing tests for my application **Action:** I not only test happy paths, but also sad paths and edge cases. | [ ] | [ ] |
| **Context:** When writing tests for my application **Action:** I write my test code in such a way as to be anti-fragile. | [ ] | [ ] |
| **Context:** When writing tests for my application **Action:** I test behaviors not implementation  | [ ] | [ ] |



## Beliefs

| Embodied Belief   |      Felt      | Demonstrated |
|:-------------|:------------------:|:--------:|
| Writing automated test help save time and money | [ ] | [ ] |
| World class developers all write tests | [ ] | [ ] |
| Building application following TDD is fun and more productive. | [ ] | [ ] |
| Test helps give me confidence to make large scale changes | [ ] | [ ] |
| Automated test gives me confidence that my program works as it should | [ ] | [ ] |
| Automated test help catch regression errors | [ ] | [ ] |
| Automated test serve as living documentation | [ ] | [ ] |
| TDD helps improve the design of my application | [ ] | [ ] |
| TDD enables me to be in a state of flow. | [ ] | [ ] |
| TDD is not a silver bullet | [ ] | [ ] |
